Arquitectura SaaS Multi-Tenant V1Sistema de Gestión de Costos e InventarioDiseño Escalable para 1.000+ Empresas ActivasStack: React + Vite + Supabase (Postgres + RLS + Auth)Febrero 2026Tabla de ContenidosTabla de Contenidos	3Introducción	6A) Modelo de Datos Propuesto	7Core Schema: Authentication & Tenancy	7Tabla: companies	7Tabla: subscription_plans	7Tabla: users	8Tabla: company_members	8Business Domain: Products & Inventory	9Tabla: products	9Tabla: inventory_movements	9Auditing & Compliance	10Tabla: audit_logs	10Tabla: company_usage_metrics	10Tabla: ai_usage_logs	11B) Estrategia de RLS Multi-Tenant	12Helper Functions para RLS	12Ejemplo de RLS Policy: Products	12Consideraciones Críticas de Performance	12Service Role Bypass	12C) Diseño del Sistema de Roles	13Jerarquía de Roles	13Enforcement en Tres Capas	13Reglas de Transición de Roles	13D) Arquitectura de Suscripciones	14Estado Machine	14Definiciones de Estados	14Integración con Stripe	14Reconciliación Diaria	14E) Manejo de Límites por Plan	15Estrategia de Enforcement	15Warnings Proactivos	15Cálculo de Usage Tracking	15F) Estrategia de Suspensión	16Niveles de Suspensión	16Implementación en Tres Capas	16Grace Periods para Retention	16G) Sistema de Auditoría	17Eventos Auditados	17Implementación via Database Triggers	17Política de Retención	17Partitioning para Escala	17H) Escalabilidad hasta 1.000 Empresas	18Database Optimization	18Estrategia de Indexing	18Connection Pooling	18Application Layer Optimization	18Caching Strategy	18Rate Limiting	18Monitoring & Alerting	18Métricas Críticas a Trackear	18Alerting Thresholds	18I) Riesgos Técnicos	201. Data Leakage (Severity: CRITICAL)	202. Cascading Deletion Hell (Severity: HIGH)	203. Subscription State Drift (Severity: HIGH)	204. Role Escalation Vulnerability (Severity: CRITICAL)	205. Query Performance Degradation (Severity: MEDIUM)	20J) Recomendaciones Estratégicas	211. Design for Multi-Region Desde Día 1	212. Feature Flags en DB, No en Código	213. API Versioning Desde V1	214. Observability as Code	215. Data Retention Policies From Day 1	216. Schema Migration Strategy	217. Billing Buffer: Nunca Suspendas Instantáneamente	218. Escape Hatches para Support	219. Plan Migration Path	2110. Documentation as Code	22Conclusión: Production-Ready Checklist	23Apéndice: Referencias Técnicas	24Stack Tecnológico	24Convenciones de Código	24Recursos Adicionales	24IntroducciónEste documento presenta una arquitectura SaaS multi-tenant robusta, diseñada para soportar al menos 1.000 empresas activas sin necesidad de refactorización estructural. La arquitectura está optimizada para un sistema de gestión de costos e inventario (cost-margin manager) con las siguientes características clave:Multi-tenant isolation real con company_id en todas las tablasSistema de roles jerárquico (SuperAdmin, Owner, Admin, Manager, Operator, Viewer)Subscription model profesional con estados trialing, active, past_due, suspended, canceledPlanes con límites configurables (users, products, storage, AI quota)Suspensión inteligente (read-only mode y bloqueo total)Auditoría completa de todas las operaciones críticasIntegración con Stripe para gestión de pagosPreparado para uso de IA (Gemini/OpenAI) con cuotas por planA) Modelo de Datos PropuestoCore Schema: Authentication & TenancyLa arquitectura se basa en una jerarquía de isolation donde companies → company_members ← users. Esto permite que los usuarios pertenezcan a múltiples empresas mientras se mantiene el aislamiento de datos.Tabla: companiesCampoTipoDescripciónidUUIDPrimary key generada automáticamenteslugTEXTIdentificador amigable para URLs (ej: acme-corp)nameTEXTNombre de la empresasubscription_statusTEXTEstado: trialing, active, past_due, suspended, canceledsubscription_tierTEXTPlan: starter, professional, enterprisestripe_customer_idTEXTID del cliente en Stripestripe_subscription_idTEXTID de la suscripción en Stripesuspension_levelTEXTNivel: none, read_only, blockedtrial_ends_atTIMESTAMPTZFecha de fin del período de pruebagrace_period_ends_atTIMESTAMPTZFecha de fin del grace periodTabla: subscription_plansCampoTipoDescripciónidUUIDPrimary keyslugTEXTstarter, professional, enterprisemonthly_price_centsINTEGERPrecio mensual en centavosmax_usersINTEGERLímite de usuarios permitidosmax_productsINTEGERLímite de productosmax_storage_mbINTEGERLímite de almacenamiento en MBmax_ai_requests_monthlyINTEGERCuota mensual de requests de IAfeaturesJSONBFeature flags configurablesTabla: usersCampoTipoDescripciónidUUIDReferences auth.users(id)emailTEXTEmail único del usuariofull_nameTEXTNombre completodefault_company_idUUIDEmpresa por defectois_super_adminBOOLEANFlag para SuperAdmins globalesTabla: company_membersEsta tabla es crítica para el sistema multi-tenant, ya que define la relación muchos-a-muchos entre usuarios y empresas, junto con el rol de cada usuario en cada empresa.CampoTipoDescripciónidUUIDPrimary keycompany_idUUIDReferences companies(id)user_idUUIDReferences users(id)roleTEXTowner, admin, manager, operator, viewerinvited_byUUIDUsuario que invitó a este miembrois_activeBOOLEANEstado del miembro (permite desactivación sin borrado)deactivated_atTIMESTAMPTZFecha de desactivaciónBusiness Domain: Products & InventoryTabla: productsCampoTipoDescripciónidUUIDPrimary keycompany_idUUIDCRITICAL: Aislamiento multi-tenantskuTEXTCódigo único del productonameTEXTNombre del productobase_costDECIMAL(12,4)Costo base del productoselling_priceDECIMAL(12,4)Precio de ventamargin_percentageDECIMAL(5,2)Margen calculado automáticamente (GENERATED COLUMN)current_stockINTEGERInventario actualcreated_byUUIDUsuario que creó el productoupdated_byUUIDUsuario que actualizó por última vezTabla: inventory_movementsCampoTipoDescripciónidUUIDPrimary keycompany_idUUIDAislamiento multi-tenantproduct_idUUIDReferences products(id)movement_typeTEXTpurchase, sale, adjustment, returnquantityINTEGERCantidad del movimientounit_costDECIMAL(12,4)Costo unitarioreference_numberTEXTNúmero de referencia (factura, orden, etc.)movement_dateTIMESTAMPTZFecha del movimientocreated_byUUIDUsuario que registró el movimientoAuditing & ComplianceTabla: audit_logsSistema completo de auditoría que registra quién hizo qué y cuándo. Crítico para compliance, debugging y análisis de seguridad.CampoTipoDescripciónidUUIDPrimary keycompany_idUUIDEmpresa afectadauser_idUUIDUsuario que ejecutó la acciónuser_emailTEXTEmail denormalizado (para retención post-deletion)user_roleTEXTRol del usuario al momento de la acciónactionTEXTcreate, update, delete, login, export, etc.resource_typeTEXTproduct, user, company_settings, etc.resource_idUUIDID del recurso afectadoold_valuesJSONBValores antes del cambionew_valuesJSONBValores después del cambioip_addressINETIP del usuariouser_agentTEXTUser agent del navegadorcreated_atTIMESTAMPTZTimestamp del eventoTabla: company_usage_metricsMétricas de uso para enforcement de límites por plan y análisis de negocio (MRR, churn, etc.).CampoTipoDescripcióncompany_idUUIDEmpresa medidaperiod_startTIMESTAMPTZInicio del períodoperiod_endTIMESTAMPTZFin del períodoactive_users_countINTEGERUsuarios activosproducts_countINTEGERNúmero de productosstorage_used_mbDECIMAL(12,2)Almacenamiento usadoai_requests_countINTEGERRequests de IA realizadosis_snapshotBOOLEANfalse=agregado, true=punto en el tiempoTabla: ai_usage_logsCampoTipoDescripcióncompany_idUUIDEmpresauser_idUUIDUsuario que hizo el requestproviderTEXTopenai o geminimodelTEXTModelo usado (gpt-4, gemini-pro, etc.)prompt_tokensINTEGERTokens del promptcompletion_tokensINTEGERTokens de la respuestaestimated_cost_centsINTEGERCosto estimado en centavosfeatureTEXTFuncionalidad (cost_analysis, price_suggestion, etc.)B) Estrategia de RLS Multi-TenantRow Level Security (RLS) es la piedra angular del aislamiento multi-tenant. Implementamos una estrategia de defense in depth con tres principios fundamentales:Zero trust: Cada query debe probar tenancy, incluso desde backendPerformance-first: Indexes deben soportar las RLS policiesFail-secure: En caso de duda, denegar accesoHelper Functions para RLSFunciones SQL que encapsulan la lógica de autenticación y autorización, usadas en todas las policies:auth.user_id(): Obtiene el ID del usuario actual desde el JWTauth.is_super_admin(): Verifica si el usuario es SuperAdmin globalauth.user_companies(): Retorna lista de companies del usuarioauth.has_role_level(): Verifica si el usuario tiene el rol mínimo requeridoEjemplo de RLS Policy: ProductsLas policies de productos demuestran el patrón de enforcement por rol:SELECT: Todos los miembros de la company pueden ver productosINSERT: Operators y superiores pueden crear productosUPDATE: Managers y superiores pueden editar productosDELETE: Managers y superiores pueden eliminar productosConsideraciones Críticas de PerformanceCada RLS policy añade una subquery a cada query. Con 1.000+ companies, esto puede degradar performance. Mitigaciones:Indexes compuestos: CREATE INDEX ON company_members(user_id, company_id) WHERE is_active = trueMaterialized views: Para auth.user_companies() si la performance degradaRefresh programado: Cada 5 minutos para balance entre freshness y performanceService Role BypassCRÍTICO: Backend operations usando service_role key bypasean RLS completamente. Esto es correcto para system operations (billing webhooks, scheduled jobs), pero NUNCA pasar service_role key a frontend.C) Diseño del Sistema de RolesJerarquía de RolesRolScopeCapabilities PrincipalesSuperAdminGlobalFull system access, cross-company operations, billing managementOwnerPor empresaSubscription management, add/remove members, delete company, billingAdminPor empresaManage members (non-owners), company settings, audit logs, exportsManagerPor empresaFull CRUD on business data, approve workflows, reportsOperatorPor empresaCreate records, no edit/delete, limited reportingViewerPor empresaRead-only access, no data modificationEnforcement en Tres CapasEl sistema de roles se enforcea en tres niveles para garantizar seguridad y UX óptima:1. RLS Layer (Postgres): Hard boundary que no puede ser bypaseado por bugs de aplicación2. Application Layer (Edge Functions): Optimización de UX, oculta acciones no autorizadas3. UI Layer (React): Progressive disclosure, muestra/oculta features según rolReglas de Transición de RolesPara prevenir vulnerabilidades de escalación de privilegios:Owner → Owner: NO permitido (debe haber exactamente 1 owner)Owner → Admin: Permitido solo si existe otro ownerAdmin → Owner: Permitido solo por owner existenteSelf-demotion: Owners pueden degradarse si existe otro ownerOrphan protection: No se puede eliminar el último ownerD) Arquitectura de SuscripcionesEstado MachineEl sistema de suscripciones implementa una máquina de estados finitos que garantiza transiciones válidas:EstadoAccesoDuración TípicatrialingFull access14 días (configurable)activeFull accessIndefinido mientras paguepast_dueRead-only7 días grace periodsuspendedExport-onlyIndefinido hasta reactivarcanceledExport-only30 días, luego bloqueadoDefiniciones de Estadostrialing: Período de prueba inicial (14 días), full access, no payment requeridoactive: Suscripción pagada y activa, acceso completo según planpast_due: Payment falló, grace period de 7 días, modo read-onlysuspended: Grace period expirado, acceso bloqueado excepto export de datoscanceled: Usuario canceló, export-only por 30 días, data retention 90 díasIntegración con StripeWebhooks críticos que deben procesarse:customer.subscription.created → trialing/activeinvoice.payment_failed → past_due (1er intento), suspended (3+ intentos)invoice.payment_succeeded → activecustomer.subscription.deleted → canceledReconciliación DiariaCRÍTICO: Los webhooks pueden fallar. Se requiere un job diario que reconcilia el estado local con Stripe para prevenir state drift (companies activas sin pagar).E) Manejo de Límites por PlanEstrategia de EnforcementLímiteTipo de EnforcementTimingmax_usersSynchronousBloqueo inmediato en signupmax_productsAsynchronousCheck diario + warningmax_storageAsynchronousCheck diario + warningAI requestsHybridSoft warning, hard block al límiteWarnings ProactivosPara mejorar la experiencia del usuario y reducir churn:Warning al 80% del límite: Notificación in-app y emailWarning al 90%: Notificación urgente con CTA a upgradeAl 100%: Bloqueo con mensaje claro de upgrade requiredCálculo de Usage TrackingJob diario (pg_cron) que calcula métricas de uso para cada company y las almacena en company_usage_metrics. Esto permite verificación de límites sin queries pesadas en tiempo real.F) Estrategia de SuspensiónNiveles de SuspensiónNivelQueriesMutationsDuraciónnonePermitidosPermitidasNormal operationread_onlySELECTBloqueadasIndefinido (past_due) o 30d (canceled)blockedExport onlyBloqueadasIndefinido hasta reactivaciónImplementación en Tres Capas1. Application Layer: Middleware que verifica suspension_level antes de mutations2. Database Layer: Triggers que previenen mutations en companies suspendidas3. Frontend Layer: Guards React que muestran banners o full-screen blockersGrace Periods para RetentionLos grace periods son críticos para reducir churn causado por payment failures temporales (40% son tarjetas expiradas):Payment fails → 7 días grace period (read-only)Grace expires → 3 días suspended (export-only)Total: 10 días buffer antes de hard blockG) Sistema de AuditoríaEventos AuditadosAuthentication: login, logout, password_reset, mfa_enabledAuthorization: role_changed, permission_deniedData: create, update, delete (todas las entidades críticas)Configuration: settings_changed, plan_upgradedSecurity: suspicious_activity, rate_limit_exceededCompliance: data_exported, gdpr_requestImplementación via Database TriggersTriggers automáticos en Postgres capturan todas las operaciones críticas sin necesidad de código en la aplicación, garantizando que ningún cambio quede sin auditar.Política de RetenciónCompanies activas: Retención indefinidaCompanies canceladas: 90 días post-cancellationGDPR requests: 30 días para compliance, luego anonymizationPartitioning para EscalaCuando audit_logs supere 10M records, implementar table partitioning por mes para mantener query performance. Las particiones antiguas pueden archivarse a cold storage (S3).H) Escalabilidad hasta 1.000 EmpresasDatabase OptimizationEstrategia de IndexingComposite indexes para queries multi-tenant más comunesPartial indexes para reducir tamaño (ej: WHERE is_active = true)Covering indexes (INCLUDE) para evitar table lookupsConnection PoolingCon 1000 companies × 10 users concurrentes promedio = ~10k potential connections:max_connections en Postgres: 500 (Supabase Pro)pgBouncer pool mode: Transaction (no Session)Frontend: Connection reuse via Supabase client singletonApplication Layer OptimizationCaching StrategyRedis para plan limits (raramente cambian, cache 1 hora)Invalidación en plan changesMaterialized views para user permissions (refresh cada 5min)Rate LimitingRate limiting per-company (no global) para evitar que una company abuse de resources y afecte a otras. Implementar con Upstash Ratelimit: 100 requests/minute por company.Monitoring & AlertingMétricas Críticas a TrackearCategoríaMétricaThresholdPerformanceavg_query_time_ms< 500msPerformancep95_query_time_ms< 1000msScaleactive_companies_countTrackear crecimientoDatabasedb_connection_pool_usage< 80%Databasedb_cache_hit_ratio> 95%BusinessMRRTrackear crecimientoBusinesschurn_rate< 5% MoMAlerting ThresholdsDB connection pool > 80% → Scale up Supabase tierAvg query time > 500ms → Investigar missing indexesError rate > 1% → Incident responseChurn rate > 5% MoM → Product investigationI) Riesgos Técnicos1. Data Leakage (Severity: CRITICAL)Riesgo: Sin RLS adecuado, un bug en frontend/backend puede exponer data de Company A a Company B.Mitigación: RLS habilitado en TODAS las tablas multi-tenant, integration tests que verifican isolation, audit logs que detectan cross-tenant queries.2. Cascading Deletion Hell (Severity: HIGH)Riesgo: Eliminar una company sin soft-delete causa pérdida irreversible de data, violando compliance.Mitigación: Soft delete (deleted_at column), scheduled job para hard-delete después de 90 días, políticas RLS que excluyen deleted records.3. Subscription State Drift (Severity: HIGH)Riesgo: Stripe webhook falla, local state queda out-of-sync, company sigue activa sin pagar.Mitigación: Daily reconciliation job que compara local state con Stripe API, corrige discrepancias automáticamente.4. Role Escalation Vulnerability (Severity: CRITICAL)Riesgo: User con role operator puede modificar su propio role a owner si no hay validación.Mitigación: Database trigger que previene self-role-escalation y escalation above current role.5. Query Performance Degradation (Severity: MEDIUM)Riesgo: RLS policies añaden subqueries. Con 1000 companies, auth.user_companies() puede volverse lento.Mitigación: Materialized view para user_company_access, refresh cada 5 minutos, indexes agresivos.J) Recomendaciones Estratégicas1. Design for Multi-Region Desde Día 1Aunque uses single-region inicialmente, diseña pensando en replicación:Evita sequences, usa UUIDsNo uses NOW() para business logic (usa app-level timestamps)Siempre timezone-aware timestamps (TIMESTAMPTZ)2. Feature Flags en DB, No en CódigoAlmacenar feature flags en database permite A/B testing, gradual rollouts y emergency killswitches sin deployments.3. API Versioning Desde V1Aunque sea internal API, usa versioning (/api/v1/products). Cuando necesites breaking changes, lanzas /api/v2/ y deprecas v1 gradualmente.4. Observability as CodeInstrumenta todas las operaciones críticas con OpenTelemetry desde el inicio. Esto te permite debugging distribuido cuando tengas 1000 companies.5. Data Retention Policies From Day 1Auto-archive old data (ej: inventory movements > 2 años) para prevenir que tablas principales crezcan indefinidamente.6. Schema Migration StrategyUsa migrations versionadas desde inicio (Supabase CLI o Flyway). Nunca modifiques migrations existentes, siempre añade nuevas.7. Billing Buffer: Nunca Suspendas InstantáneamenteGrace periods son críticos para retention. Total 10 días buffer antes de hard block reduce churn causado por tarjetas expiradas.8. Escape Hatches para SupportSuper admin debe poder bypass suspension para casos de support, permitiendo resolver issues sin emergency deployments.9. Plan Migration PathSoporte para plan downgrades/upgrades mid-cycle con validación de limits antes de downgrade.10. Documentation as CodeMantén schema diagrams, API docs y runbooks en repo. Automatiza generación de docs desde schema.Conclusión: Production-Ready ChecklistAntes de lanzar a producción con customers reales, verifica:✓ComponenteStatus☐Multi-tenancyRLS en todas las tablas, isolation tests passing☐RolesJerarquía implementada, enforcement en 3 layers☐SubscriptionsState machine completo, Stripe webhooks tested☐LimitsEnforcement real-time para users, warnings a 80%☐SuspensionGrace periods configurados, escape hatches activos☐AuditTriggers en tablas críticas, retention policy definida☐IndexesComposite indexes para queries multi-tenant☐MonitoringMetrics collection activo, alertas configuradas☐MigrationsVersionadas, testeable, rollback strategy☐DocumentationAPI docs, schema diagrams, runbooksEsta arquitectura soportará 1.000 companies sin refactor estructural. Cada componente tiene un propósito claro, y puedes iterar features de negocio sin tocar la foundation.Apéndice: Referencias TécnicasStack TecnológicoFrontend: React 18+ con Vite para desarrollo rápidoBackend: Supabase (Postgres 15+, Row Level Security, Auth)Payments: Stripe (Customer Portal, Subscriptions, Webhooks)AI: OpenAI GPT-4 / Google Gemini ProMonitoring: Datadog / Sentry para observabilityCaching: Redis (Upstash) para session & rate limitingConvenciones de CódigoTodas las tablas multi-tenant DEBEN tener company_id NOT NULLUsar UUIDs para todos los IDs (gen_random_uuid())Timestamps siempre TIMESTAMPTZ (timezone-aware)Soft delete preferido sobre hard delete (deleted_at column)Audit logs inmutables (no UPDATE/DELETE except by super admin)Recursos AdicionalesSupabase RLS Documentation: https://supabase.com/docs/guides/auth/row-level-securityStripe Subscription Lifecycle: https://stripe.com/docs/billing/subscriptions/overviewMulti-tenant Best Practices: https://aws.amazon.com/blogs/database/multi-tenant-data-isolation-with-postgresql-row-level-security/
