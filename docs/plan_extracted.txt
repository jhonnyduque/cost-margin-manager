PROYECTO SAAS MULTI-TENANTPlan de Implementación por FasesArquitectura Gobernable, Delegable y MonetizableDOCUMENTO VERIFICABLE CON CRITERIOS DE ACEPTACIÓNStack Tecnológico:React + Vite | Supabase (Postgres + RLS + Auth) | Stripe | OpenAI/GeminiVersión: 1.0 FinalFebrero 2026Executive SummaryObjetivo del DocumentoEste documento define la arquitectura completa y el plan de implementación por fases para un SaaS multi-tenant escalable a 1.000+ empresas activas. Integra arquitectura técnica, auditoría de riesgos, fixes críticos y criterios de aceptación verificables para cada fase.Principios FundamentalesGobernabilidad: El sistema se auto-gobierna sin intervención manual del fundadorDelegabilidad: Equipos pueden operar módulos sin conocer todo el sistemaMonetización Enforceable: Revenue leakage estructuralmente imposibleSeguridad Primero: Multi-tenant isolation verificado en cada faseEstructura del Plan de ImplementaciónFaseDuraciónObjetivoBloqueantePhase 0: Foundation2 semanasCore tenancy + RLS bulletproofNO pasar sin 100% testsPhase 1: Monetization2 semanasStripe + subscription lifecycleNO pasar sin reconciliationPhase 2: Limits & Enforcement2 semanasQuotas + suspension granularNO pasar sin race condition fixPhase 3: Business Domain3 semanasProducts, inventory, featuresIterable sin romper corePhase 4: Operability2 semanasAuto-governance + complianceNO lanzar sin runbooksRiesgos Críticos MitigadosRiesgoSeveridadMitigaciónFaseData leakage multi-tenantCRÍTICARLS + integration testsPhase 0Revenue leakageEXISTENCIALReconciliation + DB triggersPhase 1Race conditions en limitsALTADB atomic locksPhase 2Noisy neighbor CPU/IOPSALTAQuery timeouts + throttlingPhase 2Migrations rompen RLSCRÍTICATemplate obligatorio + pre-commitPhase 0Caché permisos inconsistenteMEDIACache invalidation + triggersPhase 4Export abuse suspendedMEDIARate limits + signed URLsPhase 4IMPORTANTE: Cada fase tiene criterios de aceptación verificables. NO avanzar a la siguiente fase sin completar el 100% de los criterios. Este documento es la única fuente de verdad para el proyecto.Tabla de ContenidosExecutive Summary	3Tabla de Contenidos	51. Arquitectura Core del Sistema	81.1 Layers de Arquitectura	81.2 Modelo de Datos Core	81.2.1 Tabla: companies	81.2.2 Tabla: users	91.2.3 Tabla: company_members	91.2.4 Tabla: subscription_plans	101.3 Business Domain Tables	101.3.1 Tabla: products	101.3.2 Tabla: inventory_movements	111.4 Auditing & Compliance Tables	121.4.1 Tabla: audit_logs (Partitioned)	121.4.2 Tabla: internal_actions_log	121.5 Usage Tracking & Metrics	141.5.1 Tabla: company_usage_metrics	141.5.2 Tabla: ai_usage_logs	141.6 Row Level Security (RLS) Policies	161.6.1 Helper Functions	161.6.2 Ejemplo: RLS Policies en products	162. Auditoría de Riesgos y Gaps Identificados	172.1 Matriz de Riesgos por Severidad	172.2 Riesgos Críticos Detallados	19R1: Race Condition en User Limits	19R2: Audit Logs Mutables	19R8: Subscription Status Inconsistente	19R14: Audit Logs Sin Partitioning	19R23: Migrations Rompen RLS	193. Plan de Implementación por Fases	213.1 Visión General de Fases	21PHASE 0: Foundation (Semanas 1-2)	22Deliverables Obligatorios	22Criterios de Aceptación (100% requerido)	23Testing Requerido	24PHASE 1: Monetization Core (Semanas 3-4)	25Deliverables Obligatorios	25Criterios de Aceptación (100% requerido)	25Testing Requerido	26PHASE 2: Limits & Enforcement (Semanas 5-6)	27Deliverables Obligatorios	27Criterios de Aceptación (100% requerido)	27Testing Requerido	28PHASE 3: Business Domain (Semanas 7-9)	30Deliverables Obligatorios	30Criterios de Aceptación (100% requerido)	30Testing Requerido	31PHASE 4: Operability & Scale (Semanas 10-11)	32Deliverables Obligatorios	32Criterios de Aceptación (100% requerido)	33Testing Requerido	334. Estrategia de Testing Integral	354.1 Tipos de Tests por Fase	354.2 Test Coverage Mínimo	354.3 Tests de Seguridad Obligatorios	35Multi-Tenant Isolation Tests (Phase 0)	35Revenue Protection Tests (Phase 1-2)	365. Checklists de Control por Fase	375.1 Phase 0: Foundation - Checklist Final	375.2 Phase 1: Monetization - Checklist Final	395.3 Phase 2: Limits & Enforcement - Checklist Final	415.4 Phase 3: Business Domain - Checklist Final	435.5 Phase 4: Operability - Checklist Final	446. Launch Readiness Checklist	466.1 Pre-Launch Checklist Técnico	466.2 Pre-Launch Checklist Operativo	476.3 Pre-Launch Checklist Legal/Compliance	47Apéndice: Referencias Técnicas	49A. Stack Tecnológico	49B. Convenciones de Código	49C. Recursos Adicionales	49D. Contactos de Emergencia	49Control de Versiones	511. Arquitectura Core del SistemaEsta sección define la arquitectura técnica completa con todos los fixes de seguridad y escalabilidad integrados. Cada componente está diseñado para soportar 1.000+ empresas activas sin refactor estructural.1.1 Layers de ArquitecturaEl sistema se estructura en 4 layers con diferentes niveles de estabilidad:LayerEstabilidadResponsabilidadDelegabilidadCore Tenancy5+ añosMulti-tenant isolation, auth, RLSNO delegable (CTO)Business Domain2-3 añosProducts, inventory, featuresDelegable (Product Team)Monetization1-2 añosSubscriptions, billing, limitsDelegable (Revenue Team)Governance3+ añosAudit, compliance, GDPRDelegable (Compliance Team)1.2 Modelo de Datos Core1.2.1 Tabla: companiesTabla central del sistema. Define cada empresa (tenant) con su subscription status y metadata.CampoTipoConstraintDescripciónidUUIDPKIdentificador únicoslugTEXTUNIQUE (si deleted_at IS NULL)URL-friendly identifiernameTEXTNOT NULLNombre de la empresasubscription_statusTEXTNOT NULLtrialing, active, past_due, suspended, canceledsubscription_tierTEXTNOT NULLstarter, professional, enterprisestripe_customer_idTEXTUNIQUEID en Stripestripe_subscription_idTEXTSubscription ID en Stripetrial_ends_atTIMESTAMPTZFin del trialgrace_period_ends_atTIMESTAMPTZFin del grace period (past_due)deleted_atTIMESTAMPTZSoft delete timestampcreated_atTIMESTAMPTZDEFAULT NOW()Fecha de creaciónIMPORTANTE: suspension_level NO se almacena. Se deriva de subscription_status para evitar inconsistencias (single source of truth).1.2.2 Tabla: usersCampoTipoConstraintDescripciónidUUIDPK, FK auth.usersID del usuario en Supabase AuthemailTEXTUNIQUE, NOT NULLEmail del usuariofull_nameTEXTNombre completois_super_adminBOOLEANDEFAULT falseFlag para admins globalesdefault_company_idUUIDFK companiesEmpresa por defecto del usuario1.2.3 Tabla: company_membersCrítico: Esta tabla define la relación many-to-many entre users y companies, con roles específicos por company.CampoTipoConstraintDescripciónidUUIDPKIdentificador únicocompany_idUUIDFK companies, NOT NULLEmpresauser_idUUIDFK users, NOT NULLUsuarioroleTEXTNOT NULLowner, admin, manager, operator, vieweris_activeBOOLEANDEFAULT trueEstado (permite desactivar sin borrar)invited_byUUIDFK usersUsuario que invitócreated_atTIMESTAMPTZDEFAULT NOW()Fecha de creaciónUNIQUE(company_id, user_id)Un user no puede duplicarse en una companyConstraint adicional: DB trigger previene eliminar el último owner de una company (prevent_last_owner_removal).1.2.4 Tabla: subscription_plansCampoTipoDescripciónidUUIDPKslugTEXTstarter, professional, enterprise (UNIQUE)nameTEXTNombre displaymonthly_price_centsINTEGERPrecio mensual en centavosyearly_price_centsINTEGERPrecio anual en centavosmax_usersINTEGERLímite de usuariosmax_productsINTEGERLímite de productosmax_storage_mbINTEGERLímite de storage en MBmax_ai_requests_monthlyINTEGERCuota mensual de AI requestsfeaturesJSONBFeature flags: {advanced_analytics: true, ...}stripe_monthly_price_idTEXTPrice ID en Stripestripe_yearly_price_idTEXTPrice ID en Stripe1.3 Business Domain Tables1.3.1 Tabla: productsCampoTipoDescripciónidUUIDPKcompany_idUUIDFK companies, NOT NULL (multi-tenant isolation)skuTEXTCódigo único del productonameTEXTNombre del productobase_costDECIMAL(12,4)Costo baseselling_priceDECIMAL(12,4)Precio de ventamargin_percentageDECIMAL(5,2)GENERATED COLUMN: (selling_price - base_cost) / selling_price * 100current_stockINTEGERInventario actualis_activeBOOLEANDEFAULT truedeleted_atTIMESTAMPTZSoft deletecreated_byUUIDFK usersupdated_byUUIDFK usersUNIQUE(company_id, sku)SKU único por company1.3.2 Tabla: inventory_movementsCampoTipoDescripciónidUUIDPKcompany_idUUIDFK companies, NOT NULLproduct_idUUIDFK products, NOT NULLmovement_typeTEXTpurchase, sale, adjustment, returnquantityINTEGERCantidad (positivo o negativo)unit_costDECIMAL(12,4)Costo unitarioreference_numberTEXTNúmero de factura/ordenmovement_dateTIMESTAMPTZFecha del movimientocreated_byUUIDFK users1.4 Auditing & Compliance Tables1.4.1 Tabla: audit_logs (Partitioned)CRÍTICO: Esta tabla DEBE estar particionada desde día 1 por created_at (monthly partitions). Sin esto, queries se volverán lentas a los 6 meses.CampoTipoDescripciónidUUIDPK (NOT NULL para partitioning)company_idUUIDFK companies, NOT NULLuser_idUUIDFK usersuser_emailTEXTDenormalizado para retention post-deletionuser_roleTEXTRol al momento de la acciónactionTEXTcreate, update, delete, login, export, etc.resource_typeTEXTproduct, user, company_settings, etc.resource_idUUIDID del recurso afectadoold_valuesJSONBValores antes del cambionew_valuesJSONBValores después del cambioip_addressINETIP del usuariouser_agentTEXTUser agent del navegadorcreated_atTIMESTAMPTZNOT NULL (partition key)Inmutabilidad: RLS policies DEBEN prevenir UPDATE y DELETE en esta tabla (excepto para compliance purge después de 90 días).1.4.2 Tabla: internal_actions_logAuditoría de acciones de support/admin. Separada de audit_logs porque tiene requirements diferentes.CampoTipoDescripciónidUUIDPKadmin_user_idUUIDFK users, NOT NULLadmin_emailTEXTEmail del adminadmin_roleTEXTsupport, admin, founderaction_typeTEXToverride_suspension, bypass_limit, refund, etc.affected_company_idUUIDFK companiesjustificationTEXTNOT NULL, CHECK length >= 20support_ticket_idTEXTLink a Zendesk/Intercomchanges_madeJSONBQué se modificórequires_approvalBOOLEANDEFAULT falseapproved_byUUIDFK users (si requires_approval)approved_atTIMESTAMPTZTimestamp de aprobaciónexecuted_atTIMESTAMPTZDEFAULT NOW()1.5 Usage Tracking & Metrics1.5.1 Tabla: company_usage_metricsCampoTipoDescripciónidUUIDPKcompany_idUUIDFK companies, NOT NULLperiod_startTIMESTAMPTZInicio del períodoperiod_endTIMESTAMPTZFin del períodoactive_users_countINTEGERUsuarios activosproducts_countINTEGERNúmero de productosstorage_used_mbDECIMAL(12,2)Storage usadoai_requests_countINTEGERAI requests realizadosis_snapshotBOOLEANfalse=agregado, true=punto en tiempocreated_atTIMESTAMPTZDEFAULT NOW()UNIQUE(company_id, period_start, is_snapshot)1.5.2 Tabla: ai_usage_logsCampoTipoDescripciónidUUIDPKcompany_idUUIDFK companies, NOT NULLuser_idUUIDFK usersproviderTEXTopenai, geminimodelTEXTgpt-4, gemini-pro, etc.prompt_tokensINTEGERTokens del promptcompletion_tokensINTEGERTokens de la respuestatotal_tokensINTEGERTotal tokensestimated_cost_centsINTEGERCosto estimadofeatureTEXTcost_analysis, price_suggestion, etc.created_atTIMESTAMPTZDEFAULT NOW()1.6 Row Level Security (RLS) PoliciesPRINCIPIO FUNDAMENTAL: TODA tabla con company_id DEBE tener RLS habilitado. Sin excepciones. Esto se verifica en Phase 0 con integration tests.1.6.1 Helper FunctionsFunciones SQL que encapsulan lógica de autenticación, usadas en todas las policies:FunciónRetornoDescripciónauth.user_id()UUIDID del usuario actual desde JWTauth.is_super_admin()BOOLEANVerifica si es super admin globalauth.user_companies()SETOF UUIDCompanies del usuario activoauth.user_role_in_company(company_id)TEXTRol del usuario en esa companyauth.has_role_level(company_id, min_role)BOOLEANVerifica rol mínimo requerido1.6.2 Ejemplo: RLS Policies en productsOperaciónPolicyMínimo RolSELECTVer products de sus companiesviewerINSERTCrear productsoperatorUPDATEEditar productsmanagerDELETEEliminar productsmanagerNota técnica: Super admins pueden hacer todo sin restricciones. Service role bypasea RLS completamente (solo usar en backend con migrations/jobs).2. Auditoría de Riesgos y Gaps IdentificadosEsta sección documenta TODOS los fallos y vacíos identificados en la auditoría, con sus mitigaciones integradas en el plan de implementación.2.1 Matriz de Riesgos por Severidad#RiesgoSeveridadImpactFase FixR1Race condition en user limitsCRÍTICARevenue leakagePhase 2R2Audit logs mutablesCRÍTICACompliance failurePhase 0R3Soft delete sin unique constraintALTAUX brokenPhase 0R4Cascading delete sin propagaciónALTAData inconsistencyPhase 0R5Sin disaster recovery planALTABusiness continuityPhase 4R6Sin onboarding cleanupMEDIADB bloatPhase 4R7Rate limiting no granularALTAAbuse vectorPhase 2R8Subscription status inconsistenteCRÍTICARevenue leakagePhase 1R9Owner puede auto-eliminarseALTAOrphan companiesPhase 0R10AI usage sin suspension checkALTARevenue leakagePhase 2R11Downgrade sin validaciónMEDIAUX brokenPhase 1R12Proration sin trackingMEDIARevenue confusionPhase 1R13Trial extension sin anti-abuseMEDIAFree ridersPhase 1R14Audit logs sin partitioningCRÍTICAPerformance deathPhase 0R15N+1 queries en dashboardALTAPerformancePhase 3R16Usage metrics sin aggregationALTADB overloadPhase 4R17GDPR sin implementarCRÍTICALegal liabilityPhase 4R18Data residency sin considerarALTACompliancePhase 4R19Sin runbooksALTAOperations blockedPhase 4R20Sin admin UIALTASQL dependencyPhase 4R21Sin alerting strategyMEDIABlind operationsPhase 4R22Noisy neighbor CPU/IOPSALTAPerformance degradationPhase 2R23Migrations rompen RLSCRÍTICASecurity breachPhase 0R24Caché permisos inconsistenteMEDIASecurity windowPhase 4R25Export abuse en suspendedMEDIABandwidth costPhase 4Resumen: 25 riesgos identificados. 8 CRÍTICOS (pueden matar el negocio). 12 ALTOS (degradan seriamente el servicio). 5 MEDIOS (mejoras importantes).2.2 Riesgos Críticos DetalladosR1: Race Condition en User LimitsProblema: 5 requests concurrentes pueden crear 10 usuarios cuando el límite es 5. Check no es atómico.Fix: DB trigger con row-level lock (FOR UPDATE) que previene race conditions. Implementado en Phase 2.Verificación: Test concurrente que intenta crear 10 usuarios simultáneos con límite de 5. DEBE fallar 5 requests.R2: Audit Logs MutablesProblema: Si audit_logs permite UPDATE/DELETE, un actor malicioso puede borrar evidencia de fraude.Fix: REVOKE UPDATE, DELETE en audit_logs. RLS policies que retornan false para UPDATE/DELETE. Implementado en Phase 0.Verificación: Intentar UPDATE/DELETE en audit_logs como super admin. DEBE fallar con error.R8: Subscription Status InconsistenteProblema: Dos sources of truth (subscription_status y suspension_level) pueden divergir. Company activa en Stripe pero bloqueada en DB.Fix: Eliminar suspension_level column. Derivar comportamiento de subscription_status únicamente (single source of truth). Tabla suspension_overrides para casos especiales de support.Verificación: No debe existir suspension_level column en DB schema. Logic layer debe derivar suspension de subscription_status.R14: Audit Logs Sin PartitioningProblema: En 6 meses con 1000 companies: 900M records. Queries tardan 30+ segundos sin partitioning.Fix: Tabla audit_logs DEBE crearse con PARTITION BY RANGE (created_at) desde el primer día. Job mensual crea particiones futuras automáticamente.Verificación: Query pg_partitioned_table debe mostrar audit_logs como partitioned. Deben existir al menos 3 particiones (current month + 2 future).R23: Migrations Rompen RLSProblema: Migration que hace UPDATE puede afectar 0 rows si RLS está activo y migration user no tiene acceso. O migration desactiva RLS y olvida reactivarlo.Fix: Template obligatorio para migrations: DISABLE RLS → migration → ENABLE RLS → VERIFY. Pre-commit hook valida que todas las migrations siguen el template.Verificación: Pre-commit hook rechaza commits con migrations que no tienen DISABLE/ENABLE RLS pattern. Test en staging antes de production.3. Plan de Implementación por FasesREGLA DE ORO: NO pasar a la siguiente fase sin completar el 100% de los criterios de aceptación de la fase actual. Este documento es el contrato de implementación.3.1 Visión General de FasesFaseDuraciónTeam SizeObjetivo PrincipalPhase 0: Foundation2 semanasFounder + 1 SeniorMulti-tenant isolation bulletproofPhase 1: Monetization Core2 semanasFounder + Finance EngStripe + lifecycle automationPhase 2: Limits & Enforcement2 semanas2 Backend EngineersQuotas + suspension granularPhase 3: Business Domain3 semanasProduct Team (2-3)Features iterablesPhase 4: Operability & Scale2 semanasDevOps + ComplianceAuto-governanceTotal: 11 semanas (2.75 meses) para sistema production-ready con primeros customers.PHASE 0: Foundation (Semanas 1-2)OBJETIVO: Core tenancy + RLS bulletproof. Esta fase es NO NEGOCIABLE y NO DELEGABLE.Deliverables Obligatorios✓ItemStatus☐companies table con deleted_at + partial unique index en slugPendiente☐users table con is_super_admin flagPendiente☐company_members table con constraint prevent_last_owner_removalPendiente☐subscription_plans table con todos los limits configurablesPendiente☐audit_logs table PARTITIONED por created_at (monthly)Pendiente☐internal_actions_log table para auditoría de supportPendiente☐RLS habilitado en TODAS las tablas tenant-scopedPendiente☐Helper functions: auth.user_id, auth.user_companies, auth.has_role_levelPendiente☐RLS policies para companies, users, company_membersPendiente☐DB triggers: prevent_last_owner_removal, cascade_soft_deletePendiente☐Migration template obligatorio con DISABLE/ENABLE RLS patternPendiente☐Pre-commit hook que valida migrationsPendiente☐Integration tests de multi-tenant isolation (mínimo 10 test cases)Pendiente☐RLS integrity check (job que verifica todas las tablas tienen RLS)PendienteCriterios de Aceptación (100% requerido)IDCriterioMétodo VerificaciónBloqueanteAC0.1Tabla companies existe con schema correctoQuery pg_tables + describeSÍAC0.2Partial unique index en companies.slug funcionaTest: crear company, soft delete, crear otra con mismo slugSÍAC0.3audit_logs es tabla particionadaSELECT * FROM pg_partitioned_table WHERE tablename = 'audit_logs'SÍAC0.4audit_logs tiene al menos 3 particionesCount partitions en pg_tablesSÍAC0.5No se puede UPDATE/DELETE audit_logsIntentar como super admin, debe fallarSÍAC0.6RLS habilitado en todas las tablas tenantQuery pg_class.relrowsecurity = trueSÍAC0.7No se puede eliminar último ownerTest: intentar DELETE último owner, debe fallarSÍAC0.8Soft delete propaga a child tablesTest: soft delete company, verificar products.deleted_atSÍAC0.9User de Company A NO ve data de Company BIntegration test con 2 companiesSÍAC0.10Pre-commit hook rechaza migrations sin RLSTest: commit migration inválidaSÍBLOQUEADOR: Si AC0.9 falla (multi-tenant isolation), NO pasar a Phase 1 bajo NINGUNA circunstancia. Esto es un fallo existencial.Testing RequeridoUnit tests: Helper functions (auth.user_id, auth.has_role_level)Integration tests: Multi-tenant isolation (mínimo 10 scenarios)Migration tests: Run migrations en staging DB, verify RLS activo despuésLoad test: 100 companies simultáneas haciendo queries, verificar no cross-contaminationPHASE 1: Monetization Core (Semanas 3-4)OBJETIVO: Stripe integration + subscription lifecycle automation. Revenue leakage estructuralmente imposible.Deliverables Obligatorios✓ItemStatus☐subscription_events table para trackear transitionsPendiente☐Stripe webhooks configurados (customer.subscription.*, invoice.*)Pendiente☐Subscription state machine implementado (5 estados + transitions)Pendiente☐subscriptionLifecycleOrchestrator job (corre cada 1 hora)Pendiente☐billingReconciliation job (corre cada 6 horas)Pendiente☐Grace period automation (7 días past_due → suspended)Pendiente☐Trial expiration automationPendiente☐Función getSuspensionLevel() que deriva de subscription_statusPendiente☐Downgrade validation (verifica current usage vs new limits)Pendiente☐Proration tracking (proration_events table)Pendiente☐Trial extension con anti-abuse checksPendiente☐Stripe webhook handler con idempotencyPendiente☐Reconciliation report generation y alertingPendienteCriterios de Aceptación (100% requerido)IDCriterioMétodo VerificaciónBloqueanteAC1.1Webhook payment_failed → past_dueTrigger webhook en Stripe test modeSÍAC1.2Grace period expira → suspendedSimular 7 días después de past_dueSÍAC1.3Payment succeed → activeTrigger webhook invoice.payment_succeededSÍAC1.4Reconciliation detecta state driftManualmente cambiar status en DB, verificar reconciliation lo detectaSÍAC1.5Reconciliation auto-fix funcionaVerificar auto-fix aplicado y loggedSÍAC1.6Downgrade validation bloquea si excede limitsTest: company con 10 users intenta downgrade a starter (max 5)SÍAC1.7Trial extension previene multi-accountingTest: mismo user intenta extender trial en 3 companiesSÍAC1.8Proration events se crean en upgrades/downgradesVerificar proration_events table populatedNOAC1.9No existe suspension_level column en companiesQuery information_schema.columnsSÍAC1.10getSuspensionLevel() deriva correctamenteTest todos los estados: trialing → none, past_due → read_only, etc.SÍBLOQUEADOR: Si AC1.4 falla (reconciliation no detecta drift), es revenue leakage garantizado. NO pasar a Phase 2.Testing RequeridoWebhook tests: Simular todos los eventos de Stripe (12 webhooks críticos)State machine tests: Verificar todas las transiciones válidas e inválidasReconciliation tests: Crear discrepancies intencionalmente, verificar detección y fixGrace period tests: Time-travel simulation (mock Date.now())PHASE 2: Limits & Enforcement (Semanas 5-6)OBJETIVO: Enforcement de límites por plan + suspension granular + noisy neighbor mitigation.Deliverables Obligatorios✓ItemStatus☐enforce_user_limit_atomic() DB trigger con row-level lockPendiente☐enforce_company_suspension() DB trigger en todas las tablasPendiente☐Redis counters para AI quota tracking (real-time)Pendiente☐checkAIQuota() y consumeAIQuota() functions con suspension checkPendiente☐Bulk operation throttling por tierPendiente☐Query timeout dinámico por tier (set_company_query_timeout)Pendiente☐Rate limiting granular: AI requests, data exports, invitationsPendiente☐detectNoisyNeighbors() job (corre cada 5 minutos)Pendiente☐Auto-throttle para extreme resource usagePendiente☐calculateDailyUsage() job para company_usage_metricsPendiente☐checkAndNotifyLimits() para warnings a 80% y 90%Pendiente☐Export policies por subscription_statusPendiente☐Signed URLs con expiración corta para exportsPendienteCriterios de Aceptación (100% requerido)IDCriterioMétodo VerificaciónBloqueanteAC2.1Race condition user limits resueltoTest: 10 requests concurrentes crear users con límite 5. Solo 5 deben pasarSÍAC2.2Company suspended NO puede mutar dataTest: INSERT en products con company suspended, debe fallar en DBSÍAC2.3AI request verifica suspension ANTES de consumir quotaTest: suspended company intenta AI requestSÍAC2.4Redis quota sync con DB (reconciliation)Verificar discrepancy < 5 entre Redis y DBSÍAC2.5Bulk operation respeta throttling por tierTest: starter intenta bulk de 200 records, debe fallarSÍAC2.6Query timeout mata queries > límiteTest: starter con query de 10 segundos, debe terminarse a los 5sSÍAC2.7Noisy neighbor detectado y alertadoSimular high IOPS, verificar alert enviadoNOAC2.8Warning enviado a 80% de límiteSimular company a 80% users, verificar email/in-app notificationNOAC2.9Export rate limit para suspended companiesTest: suspended company intenta 5 exports, solo 1 debe pasarSÍAC2.10Signed URL expira correctamenteGenerar URL, esperar expiración, debe fallar accessNOBLOQUEADOR: Si AC2.1 falla (race condition persiste), es revenue leakage directo. NO pasar a Phase 3.Testing RequeridoConcurrency tests: Simular 50 requests simultáneas para cada límiteSuspension tests: Verificar todas las combinaciones de status × operationLoad tests: 100 companies haciendo AI requests simultáneosThrottling tests: Verificar rate limits por operation typePHASE 3: Business Domain (Semanas 7-9)OBJETIVO: Features de producto (products, inventory, cost analysis). Esta fase DEBE iterar rápido sin romper foundation.Deliverables Obligatorios✓ItemStatus☐products table con RLS policiesPendiente☐inventory_movements table con RLS policiesPendiente☐CRUD APIs para products (con limit checks)Pendiente☐CRUD APIs para inventory_movementsPendiente☐Bulk import endpoint con throttlingPendiente☐Margin calculation (GENERATED COLUMN en DB)Pendiente☐Stock alerts (low stock threshold)Pendiente☐Cost analysis queries optimizadas (NO N+1)Pendiente☐Dashboard con aggregations (NO loops)Pendiente☐Export functionality (CSV, JSON, XLSX)Pendiente☐Audit triggers en todas las business tablesPendiente☐RLS policies enforcement verificadoPendienteCriterios de Aceptación (100% requerido)IDCriterioMétodo VerificaciónBloqueanteAC3.1Products CRUD respeta RLSTest: viewer NO puede crear productSÍAC3.2Bulk import respeta throttlingTest: bulk de 2000 records con starter plan, debe fallarSÍAC3.3Dashboard NO tiene N+1 queriesVerificar query count con 100 companies. Máximo 10 queriesSÍAC3.4Margin calculation correctaTest: product con cost $10, price $15 = 33.33% marginNOAC3.5Audit log se genera en CRUDVerificar audit_logs populated en create/update/deleteSÍAC3.6Export respeta suspension statusTest: suspended company intenta export, debe requerir approvalSÍAC3.7Stock alert triggers correctamenteTest: product con stock < threshold, verificar notificationNOAC3.8Multi-tenant isolation en business domainTest: company A NO ve products de company BSÍIMPORTANTE: Esta fase es delegable a product team. Pueden iterar features mientras NO toquen Phase 0-2 foundation.Testing RequeridoFeature tests: Cada endpoint con diferentes roles (viewer, operator, manager, admin, owner)Performance tests: Dashboard load time < 2 segundos con 1000 productsIntegration tests: Multi-tenant isolation en business featuresExport tests: Generar exports de 10K records, verificar performancePHASE 4: Operability & Scale (Semanas 10-11)OBJETIVO: Sistema se auto-gobierna. Compliance ready. Escalable a 1000+ companies.Deliverables Obligatorios✓ItemStatus☐Internal admin UI (search companies, view details, support actions)Pendiente☐Runbooks documentados (mínimo 20 scenarios)Pendiente☐Approval workflows para sensitive actionsPendiente☐Permission cache con invalidation strategyPendiente☐Real-time invalidation via pg_notifyPendiente☐GDPR data export automation (generateGDPRExport)Pendiente☐Data deletion request workflowPendiente☐Subprocessor registry públicoPendiente☐Disaster recovery plan documentadoPendiente☐Backup testing automation (monthly)Pendiente☐Trial cancellation cleanup jobPendiente☐Health checks (systemHealthCheck cada 15 min)Pendiente☐Alert routing strategy implementadoPendiente☐Materialized views para analytics (MRR, churn, etc.)Pendiente☐Monitoring dashboards (Datadog/Sentry)PendienteCriterios de Aceptación (100% requerido)IDCriterioMétodo VerificaciónBloqueanteAC4.1Admin UI permite search companiesTest: buscar company por name/email/stripe_idSÍAC4.2Support puede override suspension con approvalTest: support solicita override, founder aprueba, ejecutaSÍAC4.3Internal action log registra todoVerificar internal_actions_log populated en support actionsSÍAC4.4Permission cache invalida en role changeTest: cambiar rol, verificar inmediata invalidationSÍAC4.5GDPR export genera archivo completoTest: solicitar export, verificar ZIP contiene todas las tablasSÍAC4.6Data deletion cumple con 30 díasTest: solicitar deletion, verificar ejecuta antes de deadlineSÍAC4.7Health check detecta RLS missingDeshabilitar RLS en test table, verificar alertSÍAC4.8Backup restore funcionaTest: restore DB de backup en stagingSÍAC4.9Trial cleanup borra companies canceladasTest: trial cancelado hace 8 días, verificar soft deleteNOAC4.10Alerting ruta crítico a founder phoneSimular database_down, verificar SMS enviadoSÍBLOQUEADOR PARA LAUNCH: NO lanzar a customers reales sin completar AC4.1, AC4.5, AC4.7, AC4.8. Son requisitos operativos mínimos.Testing RequeridoAdmin UI tests: E2E testing de todas las support operationsCompliance tests: GDPR export completeness, deletion automationDR tests: Backup restore en staging mensualmenteMonitoring tests: Simular failures, verificar alerts4. Estrategia de Testing IntegralTesting NO es opcional. Cada fase requiere cobertura específica antes de avanzar.4.1 Tipos de Tests por FaseFaseUnit TestsIntegration TestsE2E TestsLoad TestsPhase 0Helper functionsMulti-tenant isolation (10+)Migration workflow100 companies simultáneasPhase 1State transitionsWebhook handlingStripe integrationN/APhase 2Limit calculationsRace conditionsSuspension enforcement50 concurrent requestsPhase 3Business logicCRUD + RLSFeature workflowsDashboard performancePhase 4Cache logicAdmin operationsGDPR exportSystem under load4.2 Test Coverage MínimoCategoríaCoverage MínimoCríticoCore tenancy (RLS)100%SÍMonetization95%SÍLimits enforcement95%SÍBusiness features80%NOAdmin operations90%SÍ4.3 Tests de Seguridad ObligatoriosMulti-Tenant Isolation Tests (Phase 0)Test 1: User de Company A intenta SELECT products de Company B → DEBE retornar 0 rowsTest 2: User de Company A intenta INSERT product con company_id de Company B → DEBE fallarTest 3: Admin de Company A intenta UPDATE user de Company B → DEBE fallarTest 4: SQL injection attempt en company_id parameter → DEBE fallarTest 5: API request sin JWT → DEBE fallar con 401Test 6: API request con JWT de Company A + company_id de Company B → DEBE fallarTest 7: Super admin puede ver/modificar cualquier company → DEBE pasarTest 8: Service role bypasea RLS → DEBE pasar (para migrations)Test 9: Nueva tabla sin RLS → Pre-commit hook DEBE rechazarTest 10: Load test 100 companies simultáneas → NO cross-contaminationRevenue Protection Tests (Phase 1-2)Test 11: Payment fails en Stripe → Company entra en past_due automáticamenteTest 12: Grace period expira → Company entra en suspended automáticamenteTest 13: Suspended company intenta mutar data → DB trigger BLOQUEATest 14: Manual change de status en DB → Reconciliation detecta y corrigeTest 15: Concurrent user creation con límite → Race condition RESUELTO5. Checklists de Control por FaseUse estas checklists para verificar el progreso. Imprimir y marcar físicamente recomendado.5.1 Phase 0: Foundation - Checklist Final✓ItemStatus☐Schema DB completo creado (companies, users, company_members, subscription_plans)Pendiente☐audit_logs table es PARTITIONED (verificar pg_partitioned_table)Pendiente☐Partial unique index en companies.slug WHERE deleted_at IS NULLPendiente☐DB trigger prevent_last_owner_removal funcionandoPendiente☐DB trigger cascade_soft_delete funcionandoPendiente☐RLS habilitado en 100% de tablas tenant-scoped (verificar pg_class)Pendiente☐Helper functions creadas y testeadas (auth.user_id, auth.user_companies, etc.)Pendiente☐RLS policies creadas para todas las tablas corePendiente☐Migration template documentado en /migrations/TEMPLATE.sqlPendiente☐Pre-commit hook instalado y funcionandoPendiente☐10+ integration tests de multi-tenant isolation PASANDOPendiente☐Test: User A NO ve data de Company B - PASANDOPendiente☐Test: No se puede eliminar último owner - PASANDOPendiente☐Test: Soft delete propaga a child tables - PASANDOPendiente☐Test: Audit logs son immutable - PASANDOPendiente☐Health check verifica RLS integrity - IMPLEMENTADOPendiente☐Documentation: Runbook de migrations - COMPLETOPendienteFIRMA DE APROBACIÓN PHASE 0:Nombre: _________________________________   Fecha: _______________Confirmo que el 100% de los criterios de Phase 0 están completados y verificados.5.2 Phase 1: Monetization - Checklist Final✓ItemStatus☐subscription_events table creadaPendiente☐Stripe webhooks configurados en Stripe DashboardPendiente☐Webhook handler implementado con idempotencyPendiente☐subscriptionLifecycleOrchestrator job configurado (cada 1 hora)Pendiente☐billingReconciliation job configurado (cada 6 horas)Pendiente☐Grace period automation (7 días) - TESTEADOPendiente☐Trial expiration automation - TESTEADOPendiente☐getSuspensionLevel() function implementadaPendiente☐NO existe suspension_level column en DB (verificado)Pendiente☐suspension_overrides table para casos especialesPendiente☐Downgrade validation implementadaPendiente☐proration_events table y trackingPendiente☐Trial extension con anti-abuse checksPendiente☐Test: payment_failed → past_due - PASANDOPendiente☐Test: Grace period expira → suspended - PASANDOPendiente☐Test: Reconciliation detecta drift - PASANDOPendiente☐Test: Downgrade validation bloquea - PASANDOPendiente☐Documentation: Subscription state machine diagramPendienteFIRMA DE APROBACIÓN PHASE 1:Nombre: _________________________________   Fecha: _______________5.3 Phase 2: Limits & Enforcement - Checklist Final✓ItemStatus☐enforce_user_limit_atomic() trigger con FOR UPDATE lockPendiente☐enforce_company_suspension() trigger en todas las tablas mutablePendiente☐Redis setup para quota trackingPendiente☐checkAIQuota() function con suspension checkPendiente☐consumeAIQuota() function con rollback on failurePendiente☐Bulk operation throttling por tierPendiente☐Query timeout dinámico (set_company_query_timeout)Pendiente☐Rate limiting granular (AI, export, invitations)Pendiente☐detectNoisyNeighbors() job (cada 5 min)Pendiente☐calculateDailyUsage() jobPendiente☐checkAndNotifyLimits() con warnings a 80% y 90%Pendiente☐Export policies por subscription_statusPendiente☐Signed URLs con expiraciónPendiente☐Test: Race condition resuelto (10 concurrent) - PASANDOPendiente☐Test: Suspended NO puede mutar - PASANDOPendiente☐Test: AI quota enforcement - PASANDOPendiente☐Test: Bulk throttling funciona - PASANDOPendiente☐Test: Query timeout mata queries largas - PASANDOPendienteFIRMA DE APROBACIÓN PHASE 2:Nombre: _________________________________   Fecha: _______________5.4 Phase 3: Business Domain - Checklist Final✓ItemStatus☐products table con RLS policiesPendiente☐inventory_movements table con RLS policiesPendiente☐CRUD APIs con authorization checksPendiente☐Bulk import con throttlingPendiente☐Dashboard sin N+1 queries (máximo 10 queries)Pendiente☐Export functionality (CSV, JSON, XLSX)Pendiente☐Audit triggers en business tablesPendiente☐Test: RLS enforcement en CRUD - PASANDOPendiente☐Test: Multi-tenant isolation - PASANDOPendiente☐Test: Dashboard performance < 2s - PASANDOPendiente☐Test: Bulk import throttling - PASANDOPendienteFIRMA DE APROBACIÓN PHASE 3:Nombre: _________________________________   Fecha: _______________5.5 Phase 4: Operability - Checklist Final✓ItemStatus☐Internal admin UI con search y view detailsPendiente☐20+ runbooks documentadosPendiente☐Approval workflows para sensitive actionsPendiente☐Permission cache con invalidationPendiente☐GDPR export automationPendiente☐Data deletion workflowPendiente☐Subprocessor registry públicoPendiente☐Disaster recovery planPendiente☐Backup testing automationPendiente☐Trial cleanup jobPendiente☐systemHealthCheck() cada 15 minPendiente☐Alert routing implementadoPendiente☐Materialized views para analyticsPendiente☐Monitoring dashboards configuradosPendiente☐Test: Admin UI funcional - PASANDOPendiente☐Test: GDPR export completo - PASANDOPendiente☐Test: Backup restore works - PASANDOPendiente☐Test: Health checks detectan issues - PASANDOPendienteFIRMA DE APROBACIÓN PHASE 4:Nombre: _________________________________   Fecha: _______________6. Launch Readiness ChecklistCRÍTICO: NO lanzar a producción con customers reales hasta completar el 100% de este checklist.6.1 Pre-Launch Checklist Técnico✓ItemStatus☐Todas las fases (0-4) completadas al 100%Pendiente☐Test suite completo PASANDO (unit + integration + E2E)Pendiente☐Multi-tenant isolation verificado con 100 companies testPendiente☐Performance test: Dashboard < 2s con 1000 productsPendiente☐Load test: 50 concurrent users sin degradationPendiente☐Security audit: Penetration testing básicoPendiente☐RLS policies verificadas en TODAS las tablasPendiente☐Audit logs partitioning funcionandoPendiente☐Stripe webhooks testeados en test modePendiente☐Reconciliation job corriendo y alertandoPendiente☐Backup automation configurado y testeadoPendiente☐Monitoring dashboards configuradosPendiente☐Error tracking (Sentry) configuradoPendiente☐Alert routing configurado (Slack, email, SMS)Pendiente☐Status page configurado (status.yourapp.com)Pendiente6.2 Pre-Launch Checklist Operativo✓ItemStatus☐Internal admin UI accesible por support teamPendiente☐20+ runbooks documentados y accesiblesPendiente☐Support email configurado (support@yourapp.com)Pendiente☐Escalation procedures documentadosPendiente☐On-call rotation definida (mínimo 2 personas)Pendiente☐Disaster recovery plan documentado y testeadoPendiente☐Incident response playbookPendiente☐Customer communication templatesPendiente☐GDPR compliance: Privacy policy, Terms of ServicePendiente☐Subprocessor list publicadaPendiente6.3 Pre-Launch Checklist Legal/Compliance✓ItemStatus☐Privacy Policy publicadaPendiente☐Terms of Service publicadosPendiente☐Cookie policy (si aplicable)Pendiente☐GDPR data processing agreement templatePendiente☐Data retention policy documentadaPendiente☐Security incident response planPendiente☐Subprocessor disclosure (página pública)Pendiente☐DPA firmado con Stripe, OpenAI, SupabasePendienteAPROBACIÓN FINAL PARA LAUNCHFounder/CTO: _________________________________   Fecha: _______________Lead Engineer: _________________________________   Fecha: _______________QA Lead: _________________________________   Fecha: _______________Apéndice: Referencias TécnicasA. Stack TecnológicoComponenteTecnologíaVersión/PlanFrontendReact + ViteReact 18+, Vite 5+Backend/DBSupabasePro plan ($25/mo) + poolingAuthSupabase AuthIncluido en SupabasePaymentsStripeStandard pricingAIOpenAI / GeminiPer-use pricingCacheUpstash RedisFree tier → ProMonitoringDatadog / SentryDeveloper plansEmailSendGrid / ResendFree tier → ScaleStorageS3 / R2Pay-as-you-goB. Convenciones de CódigoTodas las tablas multi-tenant DEBEN tener company_id UUID NOT NULLUsar UUIDs para todos los IDs (gen_random_uuid())Timestamps siempre TIMESTAMPTZ (timezone-aware)Soft delete preferido: deleted_at TIMESTAMPTZAudit logs son append-only (no UPDATE/DELETE)Migrations DEBEN seguir template con DISABLE/ENABLE RLSPre-commit hooks validan schema changesNombres de tablas: snake_case, singular para entidadesC. Recursos AdicionalesSupabase RLS: https://supabase.com/docs/guides/auth/row-level-securityStripe Subscriptions: https://stripe.com/docs/billing/subscriptionsMulti-tenant Postgres: https://aws.amazon.com/blogs/database/multi-tenant-data-isolationGDPR Compliance: https://gdpr.eu/D. Contactos de EmergenciaFounder/CTO: _________________________________Lead Engineer: _________________________________DevOps/SRE: _________________________________Supabase Support: support@supabase.ioStripe Support: support@stripe.comControl de VersionesVersiónFechaAutorCambios1.0Feb 2026CTODocumento inicial completoFIN DEL DOCUMENTOEste documento es la única fuente de verdad para el proyecto.Mantenerlo actualizado es responsabilidad del equipo técnico.
